Haskell er et standardisert, rent funksjonelt programmeringsspråk navngitt etter matematikeren Haskell Curry.
Haskell har såkalt sterk typesetting og lat evaluering, og finnes i flere implementasjoner, der GHC kanskje er den mest kjente.
Som et funksjonelt språk har Haskell funksjoner som den viktigste måten å konstruere programmer med.
Språket er dypt forankret i Currys forskning og har derfor en mer matematisk tilnærming til programmering enn imperative språk.
Et eksempel på dette er at alle variabler er uforanderlige.
Siden Haskell er et rent funksjonelt programmeringsspråk, kan ikke funksjoner ha bivirkninger.
Med andre ord kan ikke funksjoner både returnere en verdi og endre en tilstand.
Det måtte være passelig for læring, forskning og applikasjoner – inkludert store, komplekse systemer
Det skulle være beskrevet fullstendig i form av formell syntaks og semantikk.
Det skulle være fritt tilgjengelig. Enhver skulle kunne implementere språket, og distribuere det som de ønsker.
Det skulle være mulig å bruke det som grunnlag for fremtidig forskning innenfor programmeringsspråk.
Det skulle være basert på idéer som var attraktive for folk flest og samlet konsensus.
Det skulle redusere unødvendig ulikheter i funksjonelle programmeringsspråk
Gofer, en dialekt utviklet til akademisk bruk. Hadde en tilleggsfunksjon kalt "konstruktklasser" utviklet av Mark Jones.
HBC, en eldre implementasjon som ikke lenger blir vedlikeholdt. Kompilerer også til operativsystemers egen kode.
Helium, en nyere og lettere dialekt av Haskell som skal gjøre læring av språket enklere.
På grunn av at det mangler støtte for typeklasser vil mange Haskell-applikasjoner feile på denne kompilatoren.
Utrecht Haskell Compiler (UHC) er en Haskell-implementasjon fra Universitetet i Utrecht.
Støtter nesten alle Haskell 98-funksjonene i tillegg til en del eksperimentelle utvidelser.
Språket er hovedsakelig brukt til akademisk forskning innenfor genererte typesystemer og språkutvidelser.
Hugs, Haskell User's Gofer System, er en lett og portabel Haskell-kompilator som kompilerer til bytekode.
Hugs gir kjapp kompilering av applikasjoner og er relativt kjapp under kjøring.
Jhc er en Haskell-kompilator skrevet av John Meacham.
Kompilatoren setter fokus på hastighet og effektivitet av genererte programmet, så vell som utforskning av nye programendringer.
LHC er en nylig fork av Jhc.
nhc98 er en annen bytekode-kompilator.
Nhc98 er kompatibelt med Haskell 98-spesifikasjonen og fokuserer veldig på å minimisere minnebruk.
Dette gjør at Nhc98 blir spesielt god på eldre og litt tregere maskiner.
Yhc, York Haskell Compiler var en fork av nhc98.
Målet var å være enklere, mer portabel og effektiv.
Yhc integrerte støtte for Hat, en Haskell tracer.
Til forandring fra de andre inkluderte også Yhc en JavaScript-motor som lot brukeren kjøre Haskell-applikasjoner i en nettleser.
LISP (forkortelse for List Processing) er en familie av programmeringsspråk.
Den første utgaven stammer fra John McCarthys arbeid ved Massachusetts Institute of Technology og ble utviklet i 1958.
LISP har mye til felles med Lambda kalkulus. Historisk sett har LISP stort sett vært brukt innenfor forskning og det akademiske, og da spesielt til forskning på kunstig intelligens, som John McCarthy først og fremst hadde i tankene da han fant det opp.
Python er et objektorientert programmeringsspråk startet på av Guido van Rossum i 1989.
Van Rossum valgte navnet «Python» fordi han er fan av Monty Python, og fordi han mener at programmering skal være gøy.
Python var opprinnelig et scriptspråk for Amoeba OS for å lage systemendringer.
Perl, Ruby, Tcl, Scheme og tildels Java blir ofte sett på som alternativer til Python.
Python er utviklet som et fri programvare-prosjekt.
Python er et objektorientert språk, og tillater for eksempel polymorfisme.
I motsetning til i mange andre objektorienterte språk, som for eksempel Java og Smalltalk, er det allikevel fullt mulig å skrive et prosedyre-drevet program.
Programmeringsspråk er en betegnelse som henviser et ikkemenneskelig og kunstig språk som benyttes utelukkende for å styre og kontrollere en datamaskin.
I likhet med menneskelige språk har programmeringsspråk syntaks og semantiske regler for å definere mening, men i motsetning til mennesker har en datamaskin behov for å få instruksjoner beskrevet 100 % komplett, det vil si uten noen som helst for for tolkning.
Dette stiller særskilte krav til programmeringsspråkene om å være entydig og komplett.
Programmeringsspråkene inndeles gjerne i høynivå- og lavnivåspråk, avhengig av hvor ulikt programmeringsspråket er fra den maskinkoden kompilatoren vil generere.
Assembler er et typisk lavnivåspråk der kommandoer skrives nærmest direkte til prosessoren.
Basic er på den annen side et høynivåspråk hvor en kommando i programmeringsspråket ofte blir til flere, mer sammensatte, kommandoer i maskinkoden.
For høynivå programmeringsspråk skiller en gjerne mellom kompilerte språk – hvor en kompilator oversetter programteksten til direkte kjørbar maskinkode – og tolkede språk – hvor en programtolk leser programmet og utfører det fortløpende.
Etter hvert er det kommet til ulike mellomstadier, spesielt språk hvor programteksten oversettes til en plattformuavhengig bytekode som deretter eksekveres av en programtolk/et kjøretidsmiljø.
Typiske eksempler på det siste er Java, Python og noen Lisp-dialekter.
Skillet mellom kompilerte og interpreterte programmeringsspråk er flytende – to forskjellige implementasjoner av samme språk kan godt være henholdsvis det ene og det andre.
Konseptet stammer fra arbeidet nordmennene Kristen Nygaard og Ole-Johan Dahl gjorde ved Norsk Regnesentral med programmeringsspråket Simula på 1960-tallet, noe de ble belønnet med både Turing-prisen og John von Neumann-medaljen for.
OOP-konseptet fikk stor utbredelse gjennom bruk i andre programmeringsspråk, på 1970-tallet Smalltalk, på 1980-tallet C++ og på 1990-tallet Java.
Objekter – pakke data og funksjonalitet sammen i enheter i programmet. Dette er basis for modularitet, en av kvalitetene man prøver å oppnå.
Abstraksjon – gjøre at programmereren underveis kan ignorere noen av detaljene ved implementasjon av det som jobbes med.
Innkapsling – skjule den interne tilstanden til et objekt fra andre. Dette gjør at utenforstående kode ikke kan endre på tilstanden til objektet på uforutsette måter.
Polymorfi – gjøre at et objekt kan oppføre seg som et annet, bare den oppfyller den «kontrakten» grensesnittet spesifiserer.
Arv – lette arbeidet med innkapsling og polymorfi ved å tillate programmereren å lage objekter som er mer spesialiserte utgaver av andre objekter.
Objektorientert programmering har vært det rådende paradigmet siden 1990-tallet, og har både tilhengere og motstandere.
Tilhengerne peker ofte på at objekter og hierarkier både passer den virkelig verden godt og er en naturlig måte å tenke på for mennesker.
De trekker også fram at de fleste utviklere i dag er kjent med paradigmet, og kan jobbe med kode som er skrevet slik uten ekstra opplæring.
Motstanderne peker ofte på virkelige problemstillinger som passer dårlig i en objektmodell samt problemet med å bruke objektorientering i samband med relasjonsdatabaser.
